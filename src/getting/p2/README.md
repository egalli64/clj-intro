# clj-intro - Introduction to Clojure
Tested on Java 21, Clojure 1.12

# Getting Clojure
Russ Olsen (2018) The Pragmatic Programmer

https://pragprog.com/titles/roclojure/getting-clojure/

## Part 2 - Intermediate

### Chapter 10 - Sequences
Each standard collection is implemented in terms of a sequence, supporting all the methods defined in ISeq.
#### a. One Thing After Another
- [adapting vector to sequence](ch10/a/e1.clj): seq
- [list is-a sequence](ch10/a/e2.clj)
- [adapting map to sequence](ch10/a/e3.clj)
- [empty seq is nil](ch10/a/e3.clj)
#### b. A Universal Interface
- [first element](ch10/b/e1.clj): first
- [the elements beyond the first](ch10/b/e2.clj): rest
- [alternative to rest](ch10/b/e3.clj): next
- [add an element in first position](ch10/b/e4.clj): cons
- [an alternative count function](ch10/b/e5.clj)
#### c. A Rich Toolkit …
- [sorting a seqable](ch10/c/e1.clj): sort
- [reversing](ch10/c/e2.clj): reverse
- [splitting in subseq's by their size](ch10/c/e3.clj): partition, partition-all
- [merging in a seq](ch10/c/e4.clj): interleave, interpose
#### d. … Made Richer with Functional Values
- [keeping elements respecting a predicate](ch10/d/e1.clj): filter
- [get the first truthy value returned by predicate](ch10/d/e2.clj): some
#### e. Map (function)
- [map the elements maintaining the element types](ch10/e/e1.clj): map
- [extract a field from a map (structure)](ch10/e/e2.clj): map
- [extract and transform](ch10/e/e3.clj): map comp, for
#### f. Reduce
- [combine the seq elements into a result](ch10/f/e1.clj): reduce
- [get one single value from a collection](ch10/f/e2.clj)
#### g. Composing a Solution
- [an example of function composition](ch10/g/e1.clj): sort-by, reverse, take, map, interpose, apply str

### Chapter 11 - Lazy Sequences
#### a. Sequences Without End
- [lazily generate an infinite seq](ch11/a/e1.clj): repeat
#### b. More Interesting Laziness
- [lazy infinite repetition of a seq](ch11/b/e1.clj): cycle
- [lazy infinite seq generated by a function](ch11/b/e2.clj): iterate
#### c. Lazy Friends
- [lazy finite subseq from an infinite lazy seq](ch11/c/e1.clj): take
- [lazy map an infinite lazy seq](ch11/c/e2.clj): map
- [lazy interleave infinite lazy seqs](ch11/c/e3.clj): interleave
#### d. Laziness in Practice
- [a lazy example](ch11/d/e1.clj)
#### e. Behind the Scenes
- [building a lazy seq](ch11/e/e1.clj): lazy-seq
- [implementing a simple version of repeat](ch11/e/e2.clj)
- [implementing a simple version of iterate](ch11/e/e3.clj)
- [implementing a simple version of map](ch11/e/e4.clj)
#### f. Staying Out of Trouble
- [(kind of) printing an infinite seq](ch11/f/e1.clj): set! *print-length*
- [getting a file as a string](ch11/f/e2.clj): slurp doall doseq

### Chapter 12. Destructuring
#### a. Pry Open Your Data
- [destructure a collection](ch12/a/e1.clj): the [] destructuring pattern
#### b. Getting Less than Everything
- [discarding elements from destructuring_](ch12/b/e1.clj): the idiomatic dummy symbol _
- [multilevel destructuring](ch12/b/e2.clj): [[]]
#### c. Destructuring in Sequence
- [any seqable could be destructured: a list](ch12/c/e1.clj)
- [string is seqable, it could be destructured](ch12/c/e2.clj)
#### d. Destructuring Function Arguments
- [destructuring a parameter](ch12/d/e1.clj)
#### e. Digging into Maps
- [map destructuring](ch12/e/e1.clj): [{}]
#### f. Diving into Nested Maps
- [multilevel map destructuring](ch12/f/e1.clj): [{{}}]
#### g. The Final Frontier: Mixing and Matching
- [destructuring map with vector](ch12/g/e1.clj): [{[]}]
- [destructuring vector with map](ch12/g/e2.clj): [{[]}]
#### h. Going Further
- [simplify destructuring a map](ch12/h/e1.clj): the keyword :keys
- [keeping the destructured value as a whole](ch12/h/e2.clj): by :as

### Chapter 13 - Records and Protocols
#### b. Striking a More Specific Bargain with Records
- [record: map with predefined key](ch13/b/e1.clj): defrecord, ->RecordName, map->RecordName
#### c. Records Are Maps
- [record works just like a map](ch13/c/e1.clj)
#### d. The Record Advantage
- [using record or map?](ch13/d/e1.clj)
#### e. Protocols
- [define a protocol and implementing it in a record](ch13/e/e1.clj): defprotocol
#### f. Decentralized Polymorphism
- [retrofit a type with a given protocol](ch13/f/e1.clj): extend-protocol

### Chapter 14 - Tests
#### a. Spotting Bugs with clojure.test
- [defining a couple of functions](ch14/a/e1.clj)
- [testing functions](ch14/a/e1_test.clj): clojure.test, deftest, is, testing

### Chapter 15 - Spec
#### a. This Is the Data You’re Looking For
- [validating a map "by hand"](ch15/a/e1.clj)
- [alpha validation by spec](ch15/a/e2.clj): clojure.spec.alpha: valid?, and, or
#### b. Spec’ing Collections
- [spec on collection](ch15/b/e1.clj):clojure.spec.alpha: coll-of, cat, keys
#### c. Registering Specs
- [global registry for specs](ch15/c/e1.clj): clojure.spec.alpha/def
#### d. Spec’ing Maps (Again)
- [improved use of spec global registry](ch15/d/e1.clj)
#### e. Why? Why? Why?
- [debug a mismatching map](ch15/e/e1.clj): clojure.spec.alpha/explain
